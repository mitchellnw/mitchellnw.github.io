<style>
    .accuracy-plot-container {
      font: 10px sans-serif;
      font-weight: bold;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .x.axis path {
      display: none;
    }

    .line {
      fill: none;
      stroke: steelblue;
      stroke-width: 1.5px;
    }

</style>


<div id="accuracy-plot" class="accuracy-plot-container"></div>

<script>


function getSvgDimensions(svgId) {
    let svgEl = document.getElementById(svgId);
    let rect = svgEl.getBoundingClientRect();
    return rect;
}

var myData = "Sparsity	All Layers Sparse	First Layer Dense\n\
0\t77.712\t77.712\n\
10\t77.486\t77.712\n\
20\t77.622\t77.528\n\
30\t77.61\t77.325\n\
40\t77.481\t77.545\n\
50\t77.58\t77.545\n\
60\t77.34\t77.457\n\
70\t76.974\t77.086\n\
80\t76.209\t76.623\n\
90\t74.051\t75.062\n";


var margin = {
  top:20,
  right:100,
  bottom:50,
  left:40
};



var line = d3.line()
.x(function(d){
  return scaleX(d.Sparsity)
})
.y(function(d){
  return scaleY(d.temperature)
})
.curve(d3.curveBasis);

var svg = d3.select("#accuracy-plot").append("svg")
  .attr('id', 'plot-svg')
.attr("width", '100%')
.attr("height", '50vmin')
// .style("background-color","lightGreen")
.append("g")
.attr("transform","translate("+(margin.left) +","+margin.top+")")

let rect = getSvgDimensions('plot-svg');
console.log("SVG rect ", rect);


var w = rect.width - margin.left - margin.right;
var h = rect.height - margin.top - margin.bottom;

var parseDate = (x) => parseInt(x)

var scaleX = d3.scaleLinear()
  .range([0,w]);

var scaleY = d3.scaleLinear()
  .range([h,0]);

var color = d3.scaleOrdinal(d3.schemeCategory10);


var xAxis = d3.axisBottom()
  .scale(scaleX)
  .tickFormat(function(d, i) {
    return i === 0 ? 'Sparsity' : d;
  });

var yAxis = d3.axisLeft()
  .scale(scaleY)


var data = d3.tsvParse(myData);
console.log("data is",data)

color.domain(d3.keys(data[0]).filter(function(key){
  console.log("key",key)
  return key!=="Sparsity";

}))


data.forEach(function(d){
  d.Sparsity = parseDate(d.Sparsity);

});

var cities = color.domain().map(function(name){
  return {
    name:name,
    values:data.map(function(d){
      return {
        Sparsity:+d.Sparsity,
        temperature:+d[name]
      };
    })
  };
});

scaleX.domain(d3.extent(data,function(d){
  return d.Sparsity;
}));
scaleY.domain([d3.min(cities,function(c){
  return d3.min(c.values,function(v){
    return v.temperature
  })
}),d3.max(cities,function(c){
  return d3.max(c.values,function(v){
    return v.temperature;
  })
})])

console.log("cities",cities);

var legend = svg.selectAll("g")
.data(cities)
.enter()
.append("g")
.attr("class","legend");

legend.append("rect")
.attr("x",w-80)
.attr("y",function(d,i){
  return i * 20;
})
.attr("width",10)
.attr("height",10)
.style("fill",function(d){
  return color(d.name);
});

legend.append("text")
.attr("x",w-62)
.attr("y",function(d,i){
  return (i * 20) + 9;
})
.text(function(d){
  return d.name;
});

svg.append("g")
.attr("class","x axis")
.attr("transform","translate(0,"+h+")")
.call(xAxis);

svg.append("g")
.attr("class","y axis")
.call(yAxis)
.append("text")
.attr("transform","rotate(-90)")
.attr("y",6)
  .attr("x",-7)
.attr("dy",".71em")
.style("text-anchor","end")
.style("fill","black")
.text("ImageNet Top-1 Accuracy");

var city = svg.selectAll(".city")
.data(cities)
.enter().append("g")
.attr("class","city");

city.append("path")
.attr("class","line")
.attr("d",function(d){
  return line(d.values);
})
.style("stroke",function(d){
  return color(d.name)
});

city.append("text")
.datum(function(d){
  // let lastSpace = d.name.lastIndexOf(' ');
  //
  // let name = d.name.length > 17?  d.name.substring(0, lastSpace)+"\n"+ d.name.substring(lastSpace + 1, d.name.length): d.name;
  // // let name = d.name.length > 17 ? 'www' : d.name;
  return{
    name:d.name,
    value:d.values[d.values.length -1]
  };
})
.attr("transform",function(d){
  return "translate(" + scaleX(d.value.Sparsity)+","+scaleY(d.value.temperature)+")";
})
.attr("x",3)
.attr("dy",".35")
.text(function(d){
  return d.name;
});

var mouseG = svg.append("g") // this the black vertical line to folow mouse
.attr("class","mouse-over-effects");

mouseG.append("path")
.attr("class","mouse-line")
.style("stroke","black")
.style("stroke-width","1px")
.style("opacity","0");

var lines = document.getElementsByClassName("line");
var mousePerLine = mouseG.selectAll(".mouse-per-line")
.data(cities)
.enter()
.append("g")
.attr("class","mouse-per-line");

mousePerLine.append("circle")
.attr("r",7)
.style("stroke",function(d){
  return color(d.name);
})
.style("fill", "none")
.style("stroke-width", "1px")
.style("opacity", "0");

mousePerLine.append("text")
.attr("transform","translate(10,3)");

mouseG.append("rect")
.attr("width",w)
.attr("height",h)
.attr("fill","none")
.attr("pointer-events","all")
.on("mouseout",function(){
  d3.select(".mouse-line").style("opacity","0");
  d3.selectAll(".mouse-per-line circle").style("opacity","0");
  d3.selectAll(".mouse-per-line text").style("opacity","0")
})
.on("mouseover",function(){
  d3.select(".mouse-line").style("opacity","1");
  d3.selectAll(".mouse-per-line circle").style("opacity","1");
  d3.selectAll(".mouse-per-line text").style("opacity","1")

})
.on("mousemove",function(){

  var mouse = d3.mouse(this);

  d3.select(".mouse-line")
  .attr("d",function(){
    var d = "M" + mouse[0] +"," + h;
    d+=" " +mouse[0] + "," + 0;
    return d;
  })

  d3.selectAll(".mouse-per-line")
  .attr("transform",function(d,i){

    var xDate = scaleX.invert(mouse[0]),
    bisect =d3.bisector(function(d){ return d.Sparsity;}).right;
    idx = bisect(d.values,xDate);




    var beginning = 0,
     end = lines[i].getTotalLength(),
    target = null;



    while(true){
      target = Math.floor((beginning+end)/2)

      pos = lines[i].getPointAtLength(target);


      if((target ===end || target == beginning) && pos.x !==mouse[0]){
        break;
      }

      if(pos.x > mouse[0]) end = target;
      else if(pos.x < mouse[0]) beginning = target;
      else break; // position found
    }
    d3.select(this).select("text")
    .text(scaleY.invert(pos.y).toFixed(1))
    .attr("fill",function(d){
      return color(d.name)
    });
    return "translate(" +mouse[0]+","+pos.y+")";

  });



});

// original graph: https://bl.ocks.org/larsenmtl/e3b8b7c2ca4787f77d78f58d41c3da91

</script>
